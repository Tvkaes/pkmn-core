{"version":3,"sources":["../../src/cache/memory.ts","../../src/cache/storage.ts","../../src/cache/swr.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["// Generic in-memory cache with TTL support.\n// Framework-agnostic, can be used by any consumer.\n// Optimized for PokeAPI's static data patterns.\n\nexport interface CacheEntry<T> {\n  data: T\n  timestamp: number\n  stale?: boolean\n}\n\nexport interface CacheOptions {\n  maxAge?: number\n  maxSize?: number\n  staleAge?: number // Time after maxAge when data is stale but usable\n}\n\n// PokeAPI data is static - use long TTLs\nexport const CACHE_PRESETS = {\n  // For truly static data (pokemon stats, types, etc)\n  STATIC: { maxAge: 1000 * 60 * 60 * 24 * 7, staleAge: 1000 * 60 * 60 * 24 * 30 }, // 7 days fresh, 30 days stale\n  // For semi-static data (species info, forms)\n  SEMI_STATIC: { maxAge: 1000 * 60 * 60 * 24, staleAge: 1000 * 60 * 60 * 24 * 7 }, // 1 day fresh, 7 days stale\n  // For session-only caching\n  SESSION: { maxAge: 1000 * 60 * 60, staleAge: 1000 * 60 * 60 * 4 }, // 1 hour fresh, 4 hours stale\n} as const\n\nconst DEFAULT_MAX_AGE = CACHE_PRESETS.STATIC.maxAge\nconst DEFAULT_STALE_AGE = CACHE_PRESETS.STATIC.staleAge\nconst DEFAULT_MAX_SIZE = 1000\n\nexport interface CacheResult<T> {\n  data: T\n  isStale: boolean\n}\n\nexport class MemoryCache<T> {\n  private cache = new Map<string, CacheEntry<T>>()\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n\n  constructor(options: CacheOptions = {}) {\n    this.maxAge = options.maxAge ?? DEFAULT_MAX_AGE\n    this.staleAge = options.staleAge ?? DEFAULT_STALE_AGE\n    this.maxSize = options.maxSize ?? DEFAULT_MAX_SIZE\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  private evictOldest(): void {\n    if (this.cache.size < this.maxSize) return\n\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, entry] of this.cache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n    }\n  }\n\n  get(key: string): T | undefined {\n    const result = this.getWithStatus(key)\n    return result?.data\n  }\n\n  getWithStatus(key: string): CacheResult<T> | undefined {\n    const entry = this.cache.get(key)\n    const status = this.getEntryStatus(entry)\n    \n    if (status === 'expired') {\n      if (entry) this.cache.delete(key)\n      return undefined\n    }\n    \n    return {\n      data: entry!.data,\n      isStale: status === 'stale',\n    }\n  }\n\n  // Get stale data even if expired (for stale-while-revalidate)\n  getStale(key: string): T | undefined {\n    const entry = this.cache.get(key)\n    return entry?.data\n  }\n\n  set(key: string, data: T): void {\n    this.evictOldest()\n    this.cache.set(key, { data, timestamp: Date.now() })\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== undefined\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n  }\n\n  size(): number {\n    return this.cache.size\n  }\n\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n}\n\nexport function createCache<T>(options?: CacheOptions): MemoryCache<T> {\n  return new MemoryCache<T>(options)\n}\n\n// Convenience function for creating a fetch wrapper with caching\nexport function withCache<T>(\n  cache: MemoryCache<T>,\n  keyFn: (args: unknown[]) => string,\n  fetchFn: (...args: unknown[]) => Promise<T>\n): (...args: unknown[]) => Promise<T> {\n  return async (...args: unknown[]): Promise<T> => {\n    const key = keyFn(args)\n    const cached = cache.get(key)\n    if (cached !== undefined) {\n      return cached\n    }\n\n    const data = await fetchFn(...args)\n    cache.set(key, data)\n    return data\n  }\n}\n","// Persistent cache implementations for browser environments.\n// Uses localStorage for small data and IndexedDB for larger datasets.\n\nimport type { CacheEntry, CacheOptions, CacheResult } from './memory'\nimport { CACHE_PRESETS } from './memory'\n\nexport interface StorageAdapter {\n  getItem(key: string): Promise<string | null>\n  setItem(key: string, value: string): Promise<void>\n  removeItem(key: string): Promise<void>\n  keys(): Promise<string[]>\n  clear(): Promise<void>\n}\n\n// localStorage adapter (sync but wrapped as async for consistency)\nexport const localStorageAdapter: StorageAdapter = {\n  async getItem(key: string) {\n    if (typeof localStorage === 'undefined') return null\n    return localStorage.getItem(key)\n  },\n  async setItem(key: string, value: string) {\n    if (typeof localStorage === 'undefined') return\n    localStorage.setItem(key, value)\n  },\n  async removeItem(key: string) {\n    if (typeof localStorage === 'undefined') return\n    localStorage.removeItem(key)\n  },\n  async keys() {\n    if (typeof localStorage === 'undefined') return []\n    return Object.keys(localStorage)\n  },\n  async clear() {\n    if (typeof localStorage === 'undefined') return\n    localStorage.clear()\n  },\n}\n\n// IndexedDB adapter for larger datasets\nexport function createIndexedDBAdapter(dbName: string, storeName: string): StorageAdapter {\n  let dbPromise: Promise<IDBDatabase> | null = null\n\n  function getDB(): Promise<IDBDatabase> {\n    if (dbPromise) return dbPromise\n\n    dbPromise = new Promise((resolve, reject) => {\n      if (typeof indexedDB === 'undefined') {\n        reject(new Error('IndexedDB not available'))\n        return\n      }\n\n      const request = indexedDB.open(dbName, 1)\n\n      request.onerror = () => reject(request.error)\n      request.onsuccess = () => resolve(request.result)\n\n      request.onupgradeneeded = () => {\n        const db = request.result\n        if (!db.objectStoreNames.contains(storeName)) {\n          db.createObjectStore(storeName)\n        }\n      }\n    })\n\n    return dbPromise\n  }\n\n  return {\n    async getItem(key: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readonly')\n        const store = tx.objectStore(storeName)\n        const request = store.get(key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve(request.result ?? null)\n      })\n    },\n\n    async setItem(key: string, value: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.put(value, key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n\n    async removeItem(key: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.delete(key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n\n    async keys() {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readonly')\n        const store = tx.objectStore(storeName)\n        const request = store.getAllKeys()\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve(request.result.map(String))\n      })\n    },\n\n    async clear() {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.clear()\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n  }\n}\n\nexport interface PersistentCacheOptions extends CacheOptions {\n  prefix?: string\n  storage?: StorageAdapter\n}\n\nexport class PersistentCache<T> {\n  private readonly prefix: string\n  private readonly storage: StorageAdapter\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n  private memoryCache = new Map<string, CacheEntry<T>>()\n\n  constructor(options: PersistentCacheOptions = {}) {\n    this.prefix = options.prefix ?? 'pkmn-cache:'\n    this.storage = options.storage ?? localStorageAdapter\n    this.maxAge = options.maxAge ?? CACHE_PRESETS.STATIC.maxAge\n    this.staleAge = options.staleAge ?? CACHE_PRESETS.STATIC.staleAge\n    this.maxSize = options.maxSize ?? 500\n  }\n\n  private getStorageKey(key: string): string {\n    return `${this.prefix}${key}`\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  async get(key: string): Promise<T | undefined> {\n    const result = await this.getWithStatus(key)\n    return result?.data\n  }\n\n  async getWithStatus(key: string): Promise<CacheResult<T> | undefined> {\n    // Check memory first\n    const memEntry = this.memoryCache.get(key)\n    if (memEntry) {\n      const status = this.getEntryStatus(memEntry)\n      if (status !== 'expired') {\n        return { data: memEntry.data, isStale: status === 'stale' }\n      }\n    }\n\n    // Check persistent storage\n    try {\n      const stored = await this.storage.getItem(this.getStorageKey(key))\n      if (!stored) return undefined\n\n      const entry: CacheEntry<T> = JSON.parse(stored)\n      const status = this.getEntryStatus(entry)\n\n      if (status === 'expired') {\n        await this.storage.removeItem(this.getStorageKey(key))\n        return undefined\n      }\n\n      // Hydrate memory cache\n      this.memoryCache.set(key, entry)\n\n      return { data: entry.data, isStale: status === 'stale' }\n    } catch {\n      return undefined\n    }\n  }\n\n  async getStale(key: string): Promise<T | undefined> {\n    // Memory first\n    const memEntry = this.memoryCache.get(key)\n    if (memEntry) return memEntry.data\n\n    // Then storage\n    try {\n      const stored = await this.storage.getItem(this.getStorageKey(key))\n      if (!stored) return undefined\n      const entry: CacheEntry<T> = JSON.parse(stored)\n      return entry.data\n    } catch {\n      return undefined\n    }\n  }\n\n  async set(key: string, data: T): Promise<void> {\n    const entry: CacheEntry<T> = { data, timestamp: Date.now() }\n\n    // Set in memory\n    this.memoryCache.set(key, entry)\n\n    // Evict if over size\n    if (this.memoryCache.size > this.maxSize) {\n      const keys = Array.from(this.memoryCache.keys())\n      const oldest = keys[0]\n      if (oldest) this.memoryCache.delete(oldest)\n    }\n\n    // Persist\n    try {\n      await this.storage.setItem(this.getStorageKey(key), JSON.stringify(entry))\n    } catch {\n      // Storage full or unavailable - continue with memory only\n    }\n  }\n\n  async delete(key: string): Promise<boolean> {\n    this.memoryCache.delete(key)\n    try {\n      await this.storage.removeItem(this.getStorageKey(key))\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async clear(): Promise<void> {\n    this.memoryCache.clear()\n    try {\n      const keys = await this.storage.keys()\n      const prefixedKeys = keys.filter((k) => k.startsWith(this.prefix))\n      await Promise.all(prefixedKeys.map((k) => this.storage.removeItem(k)))\n    } catch {\n      // Ignore storage errors\n    }\n  }\n\n  has(key: string): boolean {\n    return this.memoryCache.has(key)\n  }\n\n  size(): number {\n    return this.memoryCache.size\n  }\n}\n\nexport function createPersistentCache<T>(options?: PersistentCacheOptions): PersistentCache<T> {\n  return new PersistentCache<T>(options)\n}\n\nexport function createIndexedDBCache<T>(\n  dbName = 'pkmn-core',\n  storeName = 'cache',\n  options?: Omit<PersistentCacheOptions, 'storage'>\n): PersistentCache<T> {\n  return new PersistentCache<T>({\n    ...options,\n    storage: createIndexedDBAdapter(dbName, storeName),\n  })\n}\n","// Stale-While-Revalidate pattern implementation.\n// Returns cached data immediately while fetching fresh data in background.\n\nimport type { CacheResult } from './memory'\nimport { MemoryCache, CACHE_PRESETS } from './memory'\nimport { PersistentCache } from './storage'\n\nexport interface SWROptions {\n  dedupe?: boolean // Dedupe concurrent requests for same key\n  dedupeInterval?: number // Time window for deduplication (ms)\n  onError?: (error: unknown, key: string) => void\n  onSuccess?: (data: unknown, key: string, isRevalidation: boolean) => void\n}\n\ntype CacheInterface<T> = {\n  get(key: string): T | undefined | Promise<T | undefined>\n  getWithStatus(key: string): CacheResult<T> | undefined | Promise<CacheResult<T> | undefined>\n  getStale(key: string): T | undefined | Promise<T | undefined>\n  set(key: string, data: T): void | Promise<void>\n}\n\nexport class SWRCache<T> {\n  private cache: CacheInterface<T>\n  private inflight = new Map<string, Promise<T>>()\n  private lastFetch = new Map<string, number>()\n  private readonly dedupe: boolean\n  private readonly dedupeInterval: number\n  private readonly onError?: (error: unknown, key: string) => void\n  private readonly onSuccess?: (data: unknown, key: string, isRevalidation: boolean) => void\n\n  constructor(cache: CacheInterface<T>, options: SWROptions = {}) {\n    this.cache = cache\n    this.dedupe = options.dedupe ?? true\n    this.dedupeInterval = options.dedupeInterval ?? 2000\n    this.onError = options.onError\n    this.onSuccess = options.onSuccess\n  }\n\n  private shouldDedupe(key: string): boolean {\n    if (!this.dedupe) return false\n    const last = this.lastFetch.get(key)\n    if (!last) return false\n    return Date.now() - last < this.dedupeInterval\n  }\n\n  async get(\n    key: string,\n    fetcher: () => Promise<T>\n  ): Promise<T> {\n    // Check cache first\n    const cached = await this.cache.getWithStatus(key)\n\n    if (cached && !cached.isStale) {\n      // Fresh data - return immediately\n      return cached.data\n    }\n\n    // Check for inflight request\n    const inflight = this.inflight.get(key)\n    if (inflight) {\n      // Return stale data if available, otherwise wait for inflight\n      if (cached) return cached.data\n      return inflight\n    }\n\n    // Check dedupe\n    if (this.shouldDedupe(key)) {\n      const stale = await this.cache.getStale(key)\n      if (stale !== undefined) return stale\n    }\n\n    // Need to fetch\n    const fetchPromise = this.fetch(key, fetcher, !!cached)\n\n    // If we have stale data, return it immediately\n    if (cached) {\n      // Revalidate in background\n      fetchPromise.catch(() => {\n        // Error handled in fetch()\n      })\n      return cached.data\n    }\n\n    // No cached data - must wait for fetch\n    return fetchPromise\n  }\n\n  private async fetch(\n    key: string,\n    fetcher: () => Promise<T>,\n    isRevalidation: boolean\n  ): Promise<T> {\n    this.lastFetch.set(key, Date.now())\n\n    const promise = fetcher()\n    this.inflight.set(key, promise)\n\n    try {\n      const data = await promise\n      await this.cache.set(key, data)\n      this.onSuccess?.(data, key, isRevalidation)\n      return data\n    } catch (error) {\n      this.onError?.(error, key)\n      throw error\n    } finally {\n      this.inflight.delete(key)\n    }\n  }\n\n  async revalidate(key: string, fetcher: () => Promise<T>): Promise<T> {\n    return this.fetch(key, fetcher, true)\n  }\n\n  async mutate(key: string, data: T): Promise<void> {\n    await this.cache.set(key, data)\n  }\n\n  isValidating(key: string): boolean {\n    return this.inflight.has(key)\n  }\n}\n\nexport function createSWR<T>(\n  cache?: CacheInterface<T>,\n  options?: SWROptions\n): SWRCache<T> {\n  const defaultCache = new MemoryCache<T>(CACHE_PRESETS.STATIC)\n  return new SWRCache<T>(cache ?? defaultCache, options)\n}\n\nexport function createPersistentSWR<T>(\n  cache: PersistentCache<T>,\n  options?: SWROptions\n): SWRCache<T> {\n  return new SWRCache<T>(cache, options)\n}\n\n// Convenience function for PokeAPI-style fetching\nexport function createPokeAPIFetcher<T>(\n  baseUrl: string,\n  cache?: CacheInterface<T>,\n  options?: SWROptions\n): (endpoint: string) => Promise<T> {\n  const swr = createSWR<T>(cache, options)\n\n  return async (endpoint: string): Promise<T> => {\n    const url = endpoint.startsWith('http') ? endpoint : `${baseUrl}${endpoint}`\n    const key = url\n\n    return swr.get(key, async () => {\n      const response = await fetch(url)\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n      return response.json() as Promise<T>\n    })\n  }\n}\n"]}