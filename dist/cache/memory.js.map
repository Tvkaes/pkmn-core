{"version":3,"sources":["../../src/cache/memory.ts"],"names":[],"mappings":"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","file":"memory.js","sourcesContent":["// Generic in-memory cache with TTL support.\n// Framework-agnostic, can be used by any consumer.\n// Optimized for PokeAPI's static data patterns.\n\nexport interface CacheEntry<T> {\n  data: T\n  timestamp: number\n  stale?: boolean\n}\n\nexport interface CacheOptions {\n  maxAge?: number\n  maxSize?: number\n  staleAge?: number // Time after maxAge when data is stale but usable\n}\n\n// PokeAPI data is static - use long TTLs\nexport const CACHE_PRESETS = {\n  // For truly static data (pokemon stats, types, etc)\n  STATIC: { maxAge: 1000 * 60 * 60 * 24 * 7, staleAge: 1000 * 60 * 60 * 24 * 30 }, // 7 days fresh, 30 days stale\n  // For semi-static data (species info, forms)\n  SEMI_STATIC: { maxAge: 1000 * 60 * 60 * 24, staleAge: 1000 * 60 * 60 * 24 * 7 }, // 1 day fresh, 7 days stale\n  // For session-only caching\n  SESSION: { maxAge: 1000 * 60 * 60, staleAge: 1000 * 60 * 60 * 4 }, // 1 hour fresh, 4 hours stale\n} as const\n\nconst DEFAULT_MAX_AGE = CACHE_PRESETS.STATIC.maxAge\nconst DEFAULT_STALE_AGE = CACHE_PRESETS.STATIC.staleAge\nconst DEFAULT_MAX_SIZE = 1000\n\nexport interface CacheResult<T> {\n  data: T\n  isStale: boolean\n}\n\nexport class MemoryCache<T> {\n  private cache = new Map<string, CacheEntry<T>>()\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n\n  constructor(options: CacheOptions = {}) {\n    this.maxAge = options.maxAge ?? DEFAULT_MAX_AGE\n    this.staleAge = options.staleAge ?? DEFAULT_STALE_AGE\n    this.maxSize = options.maxSize ?? DEFAULT_MAX_SIZE\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  private evictOldest(): void {\n    if (this.cache.size < this.maxSize) return\n\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, entry] of this.cache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n    }\n  }\n\n  get(key: string): T | undefined {\n    const result = this.getWithStatus(key)\n    return result?.data\n  }\n\n  getWithStatus(key: string): CacheResult<T> | undefined {\n    const entry = this.cache.get(key)\n    const status = this.getEntryStatus(entry)\n    \n    if (status === 'expired') {\n      if (entry) this.cache.delete(key)\n      return undefined\n    }\n    \n    return {\n      data: entry!.data,\n      isStale: status === 'stale',\n    }\n  }\n\n  // Get stale data even if expired (for stale-while-revalidate)\n  getStale(key: string): T | undefined {\n    const entry = this.cache.get(key)\n    return entry?.data\n  }\n\n  set(key: string, data: T): void {\n    this.evictOldest()\n    this.cache.set(key, { data, timestamp: Date.now() })\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== undefined\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n  }\n\n  size(): number {\n    return this.cache.size\n  }\n\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n}\n\nexport function createCache<T>(options?: CacheOptions): MemoryCache<T> {\n  return new MemoryCache<T>(options)\n}\n\n// Convenience function for creating a fetch wrapper with caching\nexport function withCache<T>(\n  cache: MemoryCache<T>,\n  keyFn: (args: unknown[]) => string,\n  fetchFn: (...args: unknown[]) => Promise<T>\n): (...args: unknown[]) => Promise<T> {\n  return async (...args: unknown[]): Promise<T> => {\n    const key = keyFn(args)\n    const cached = cache.get(key)\n    if (cached !== undefined) {\n      return cached\n    }\n\n    const data = await fetchFn(...args)\n    cache.set(key, data)\n    return data\n  }\n}\n"]}