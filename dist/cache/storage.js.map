{"version":3,"sources":["../../src/cache/memory.ts","../../src/cache/storage.ts"],"names":[],"mappings":"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","file":"storage.js","sourcesContent":["// Generic in-memory cache with TTL support.\n// Framework-agnostic, can be used by any consumer.\n// Optimized for PokeAPI's static data patterns.\n\nexport interface CacheEntry<T> {\n  data: T\n  timestamp: number\n  stale?: boolean\n}\n\nexport interface CacheOptions {\n  maxAge?: number\n  maxSize?: number\n  staleAge?: number // Time after maxAge when data is stale but usable\n}\n\n// PokeAPI data is static - use long TTLs\nexport const CACHE_PRESETS = {\n  // For truly static data (pokemon stats, types, etc)\n  STATIC: { maxAge: 1000 * 60 * 60 * 24 * 7, staleAge: 1000 * 60 * 60 * 24 * 30 }, // 7 days fresh, 30 days stale\n  // For semi-static data (species info, forms)\n  SEMI_STATIC: { maxAge: 1000 * 60 * 60 * 24, staleAge: 1000 * 60 * 60 * 24 * 7 }, // 1 day fresh, 7 days stale\n  // For session-only caching\n  SESSION: { maxAge: 1000 * 60 * 60, staleAge: 1000 * 60 * 60 * 4 }, // 1 hour fresh, 4 hours stale\n} as const\n\nconst DEFAULT_MAX_AGE = CACHE_PRESETS.STATIC.maxAge\nconst DEFAULT_STALE_AGE = CACHE_PRESETS.STATIC.staleAge\nconst DEFAULT_MAX_SIZE = 1000\n\nexport interface CacheResult<T> {\n  data: T\n  isStale: boolean\n}\n\nexport class MemoryCache<T> {\n  private cache = new Map<string, CacheEntry<T>>()\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n\n  constructor(options: CacheOptions = {}) {\n    this.maxAge = options.maxAge ?? DEFAULT_MAX_AGE\n    this.staleAge = options.staleAge ?? DEFAULT_STALE_AGE\n    this.maxSize = options.maxSize ?? DEFAULT_MAX_SIZE\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  private evictOldest(): void {\n    if (this.cache.size < this.maxSize) return\n\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, entry] of this.cache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n    }\n  }\n\n  get(key: string): T | undefined {\n    const result = this.getWithStatus(key)\n    return result?.data\n  }\n\n  getWithStatus(key: string): CacheResult<T> | undefined {\n    const entry = this.cache.get(key)\n    const status = this.getEntryStatus(entry)\n    \n    if (status === 'expired') {\n      if (entry) this.cache.delete(key)\n      return undefined\n    }\n    \n    return {\n      data: entry!.data,\n      isStale: status === 'stale',\n    }\n  }\n\n  // Get stale data even if expired (for stale-while-revalidate)\n  getStale(key: string): T | undefined {\n    const entry = this.cache.get(key)\n    return entry?.data\n  }\n\n  set(key: string, data: T): void {\n    this.evictOldest()\n    this.cache.set(key, { data, timestamp: Date.now() })\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== undefined\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n  }\n\n  size(): number {\n    return this.cache.size\n  }\n\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n}\n\nexport function createCache<T>(options?: CacheOptions): MemoryCache<T> {\n  return new MemoryCache<T>(options)\n}\n\n// Convenience function for creating a fetch wrapper with caching\nexport function withCache<T>(\n  cache: MemoryCache<T>,\n  keyFn: (args: unknown[]) => string,\n  fetchFn: (...args: unknown[]) => Promise<T>\n): (...args: unknown[]) => Promise<T> {\n  return async (...args: unknown[]): Promise<T> => {\n    const key = keyFn(args)\n    const cached = cache.get(key)\n    if (cached !== undefined) {\n      return cached\n    }\n\n    const data = await fetchFn(...args)\n    cache.set(key, data)\n    return data\n  }\n}\n","// Persistent cache implementations for browser environments.\n// Uses localStorage for small data and IndexedDB for larger datasets.\n\nimport type { CacheEntry, CacheOptions, CacheResult } from './memory'\nimport { CACHE_PRESETS } from './memory'\n\nexport interface StorageAdapter {\n  getItem(key: string): Promise<string | null>\n  setItem(key: string, value: string): Promise<void>\n  removeItem(key: string): Promise<void>\n  keys(): Promise<string[]>\n  clear(): Promise<void>\n}\n\n// localStorage adapter (sync but wrapped as async for consistency)\nexport const localStorageAdapter: StorageAdapter = {\n  async getItem(key: string) {\n    if (typeof localStorage === 'undefined') return null\n    return localStorage.getItem(key)\n  },\n  async setItem(key: string, value: string) {\n    if (typeof localStorage === 'undefined') return\n    localStorage.setItem(key, value)\n  },\n  async removeItem(key: string) {\n    if (typeof localStorage === 'undefined') return\n    localStorage.removeItem(key)\n  },\n  async keys() {\n    if (typeof localStorage === 'undefined') return []\n    return Object.keys(localStorage)\n  },\n  async clear() {\n    if (typeof localStorage === 'undefined') return\n    localStorage.clear()\n  },\n}\n\n// IndexedDB adapter for larger datasets\nexport function createIndexedDBAdapter(dbName: string, storeName: string): StorageAdapter {\n  let dbPromise: Promise<IDBDatabase> | null = null\n\n  function getDB(): Promise<IDBDatabase> {\n    if (dbPromise) return dbPromise\n\n    dbPromise = new Promise((resolve, reject) => {\n      if (typeof indexedDB === 'undefined') {\n        reject(new Error('IndexedDB not available'))\n        return\n      }\n\n      const request = indexedDB.open(dbName, 1)\n\n      request.onerror = () => reject(request.error)\n      request.onsuccess = () => resolve(request.result)\n\n      request.onupgradeneeded = () => {\n        const db = request.result\n        if (!db.objectStoreNames.contains(storeName)) {\n          db.createObjectStore(storeName)\n        }\n      }\n    })\n\n    return dbPromise\n  }\n\n  return {\n    async getItem(key: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readonly')\n        const store = tx.objectStore(storeName)\n        const request = store.get(key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve(request.result ?? null)\n      })\n    },\n\n    async setItem(key: string, value: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.put(value, key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n\n    async removeItem(key: string) {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.delete(key)\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n\n    async keys() {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readonly')\n        const store = tx.objectStore(storeName)\n        const request = store.getAllKeys()\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve(request.result.map(String))\n      })\n    },\n\n    async clear() {\n      const db = await getDB()\n      return new Promise((resolve, reject) => {\n        const tx = db.transaction(storeName, 'readwrite')\n        const store = tx.objectStore(storeName)\n        const request = store.clear()\n        request.onerror = () => reject(request.error)\n        request.onsuccess = () => resolve()\n      })\n    },\n  }\n}\n\nexport interface PersistentCacheOptions extends CacheOptions {\n  prefix?: string\n  storage?: StorageAdapter\n}\n\nexport class PersistentCache<T> {\n  private readonly prefix: string\n  private readonly storage: StorageAdapter\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n  private memoryCache = new Map<string, CacheEntry<T>>()\n\n  constructor(options: PersistentCacheOptions = {}) {\n    this.prefix = options.prefix ?? 'pkmn-cache:'\n    this.storage = options.storage ?? localStorageAdapter\n    this.maxAge = options.maxAge ?? CACHE_PRESETS.STATIC.maxAge\n    this.staleAge = options.staleAge ?? CACHE_PRESETS.STATIC.staleAge\n    this.maxSize = options.maxSize ?? 500\n  }\n\n  private getStorageKey(key: string): string {\n    return `${this.prefix}${key}`\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  async get(key: string): Promise<T | undefined> {\n    const result = await this.getWithStatus(key)\n    return result?.data\n  }\n\n  async getWithStatus(key: string): Promise<CacheResult<T> | undefined> {\n    // Check memory first\n    const memEntry = this.memoryCache.get(key)\n    if (memEntry) {\n      const status = this.getEntryStatus(memEntry)\n      if (status !== 'expired') {\n        return { data: memEntry.data, isStale: status === 'stale' }\n      }\n    }\n\n    // Check persistent storage\n    try {\n      const stored = await this.storage.getItem(this.getStorageKey(key))\n      if (!stored) return undefined\n\n      const entry: CacheEntry<T> = JSON.parse(stored)\n      const status = this.getEntryStatus(entry)\n\n      if (status === 'expired') {\n        await this.storage.removeItem(this.getStorageKey(key))\n        return undefined\n      }\n\n      // Hydrate memory cache\n      this.memoryCache.set(key, entry)\n\n      return { data: entry.data, isStale: status === 'stale' }\n    } catch {\n      return undefined\n    }\n  }\n\n  async getStale(key: string): Promise<T | undefined> {\n    // Memory first\n    const memEntry = this.memoryCache.get(key)\n    if (memEntry) return memEntry.data\n\n    // Then storage\n    try {\n      const stored = await this.storage.getItem(this.getStorageKey(key))\n      if (!stored) return undefined\n      const entry: CacheEntry<T> = JSON.parse(stored)\n      return entry.data\n    } catch {\n      return undefined\n    }\n  }\n\n  async set(key: string, data: T): Promise<void> {\n    const entry: CacheEntry<T> = { data, timestamp: Date.now() }\n\n    // Set in memory\n    this.memoryCache.set(key, entry)\n\n    // Evict if over size\n    if (this.memoryCache.size > this.maxSize) {\n      const keys = Array.from(this.memoryCache.keys())\n      const oldest = keys[0]\n      if (oldest) this.memoryCache.delete(oldest)\n    }\n\n    // Persist\n    try {\n      await this.storage.setItem(this.getStorageKey(key), JSON.stringify(entry))\n    } catch {\n      // Storage full or unavailable - continue with memory only\n    }\n  }\n\n  async delete(key: string): Promise<boolean> {\n    this.memoryCache.delete(key)\n    try {\n      await this.storage.removeItem(this.getStorageKey(key))\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async clear(): Promise<void> {\n    this.memoryCache.clear()\n    try {\n      const keys = await this.storage.keys()\n      const prefixedKeys = keys.filter((k) => k.startsWith(this.prefix))\n      await Promise.all(prefixedKeys.map((k) => this.storage.removeItem(k)))\n    } catch {\n      // Ignore storage errors\n    }\n  }\n\n  has(key: string): boolean {\n    return this.memoryCache.has(key)\n  }\n\n  size(): number {\n    return this.memoryCache.size\n  }\n}\n\nexport function createPersistentCache<T>(options?: PersistentCacheOptions): PersistentCache<T> {\n  return new PersistentCache<T>(options)\n}\n\nexport function createIndexedDBCache<T>(\n  dbName = 'pkmn-core',\n  storeName = 'cache',\n  options?: Omit<PersistentCacheOptions, 'storage'>\n): PersistentCache<T> {\n  return new PersistentCache<T>({\n    ...options,\n    storage: createIndexedDBAdapter(dbName, storeName),\n  })\n}\n"]}