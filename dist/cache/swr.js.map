{"version":3,"sources":["../../src/cache/memory.ts","../../src/cache/swr.ts"],"names":[],"mappings":"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","file":"swr.js","sourcesContent":["// Generic in-memory cache with TTL support.\n// Framework-agnostic, can be used by any consumer.\n// Optimized for PokeAPI's static data patterns.\n\nexport interface CacheEntry<T> {\n  data: T\n  timestamp: number\n  stale?: boolean\n}\n\nexport interface CacheOptions {\n  maxAge?: number\n  maxSize?: number\n  staleAge?: number // Time after maxAge when data is stale but usable\n}\n\n// PokeAPI data is static - use long TTLs\nexport const CACHE_PRESETS = {\n  // For truly static data (pokemon stats, types, etc)\n  STATIC: { maxAge: 1000 * 60 * 60 * 24 * 7, staleAge: 1000 * 60 * 60 * 24 * 30 }, // 7 days fresh, 30 days stale\n  // For semi-static data (species info, forms)\n  SEMI_STATIC: { maxAge: 1000 * 60 * 60 * 24, staleAge: 1000 * 60 * 60 * 24 * 7 }, // 1 day fresh, 7 days stale\n  // For session-only caching\n  SESSION: { maxAge: 1000 * 60 * 60, staleAge: 1000 * 60 * 60 * 4 }, // 1 hour fresh, 4 hours stale\n} as const\n\nconst DEFAULT_MAX_AGE = CACHE_PRESETS.STATIC.maxAge\nconst DEFAULT_STALE_AGE = CACHE_PRESETS.STATIC.staleAge\nconst DEFAULT_MAX_SIZE = 1000\n\nexport interface CacheResult<T> {\n  data: T\n  isStale: boolean\n}\n\nexport class MemoryCache<T> {\n  private cache = new Map<string, CacheEntry<T>>()\n  private readonly maxAge: number\n  private readonly staleAge: number\n  private readonly maxSize: number\n\n  constructor(options: CacheOptions = {}) {\n    this.maxAge = options.maxAge ?? DEFAULT_MAX_AGE\n    this.staleAge = options.staleAge ?? DEFAULT_STALE_AGE\n    this.maxSize = options.maxSize ?? DEFAULT_MAX_SIZE\n  }\n\n  private getEntryStatus(entry: CacheEntry<T> | undefined): 'fresh' | 'stale' | 'expired' {\n    if (!entry) return 'expired'\n    const age = Date.now() - entry.timestamp\n    if (age < this.maxAge) return 'fresh'\n    if (age < this.staleAge) return 'stale'\n    return 'expired'\n  }\n\n  private evictOldest(): void {\n    if (this.cache.size < this.maxSize) return\n\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, entry] of this.cache) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n    }\n  }\n\n  get(key: string): T | undefined {\n    const result = this.getWithStatus(key)\n    return result?.data\n  }\n\n  getWithStatus(key: string): CacheResult<T> | undefined {\n    const entry = this.cache.get(key)\n    const status = this.getEntryStatus(entry)\n    \n    if (status === 'expired') {\n      if (entry) this.cache.delete(key)\n      return undefined\n    }\n    \n    return {\n      data: entry!.data,\n      isStale: status === 'stale',\n    }\n  }\n\n  // Get stale data even if expired (for stale-while-revalidate)\n  getStale(key: string): T | undefined {\n    const entry = this.cache.get(key)\n    return entry?.data\n  }\n\n  set(key: string, data: T): void {\n    this.evictOldest()\n    this.cache.set(key, { data, timestamp: Date.now() })\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== undefined\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n  }\n\n  size(): number {\n    return this.cache.size\n  }\n\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n}\n\nexport function createCache<T>(options?: CacheOptions): MemoryCache<T> {\n  return new MemoryCache<T>(options)\n}\n\n// Convenience function for creating a fetch wrapper with caching\nexport function withCache<T>(\n  cache: MemoryCache<T>,\n  keyFn: (args: unknown[]) => string,\n  fetchFn: (...args: unknown[]) => Promise<T>\n): (...args: unknown[]) => Promise<T> {\n  return async (...args: unknown[]): Promise<T> => {\n    const key = keyFn(args)\n    const cached = cache.get(key)\n    if (cached !== undefined) {\n      return cached\n    }\n\n    const data = await fetchFn(...args)\n    cache.set(key, data)\n    return data\n  }\n}\n","// Stale-While-Revalidate pattern implementation.\n// Returns cached data immediately while fetching fresh data in background.\n\nimport type { CacheResult } from './memory'\nimport { MemoryCache, CACHE_PRESETS } from './memory'\nimport { PersistentCache } from './storage'\n\nexport interface SWROptions {\n  dedupe?: boolean // Dedupe concurrent requests for same key\n  dedupeInterval?: number // Time window for deduplication (ms)\n  onError?: (error: unknown, key: string) => void\n  onSuccess?: (data: unknown, key: string, isRevalidation: boolean) => void\n}\n\ntype CacheInterface<T> = {\n  get(key: string): T | undefined | Promise<T | undefined>\n  getWithStatus(key: string): CacheResult<T> | undefined | Promise<CacheResult<T> | undefined>\n  getStale(key: string): T | undefined | Promise<T | undefined>\n  set(key: string, data: T): void | Promise<void>\n}\n\nexport class SWRCache<T> {\n  private cache: CacheInterface<T>\n  private inflight = new Map<string, Promise<T>>()\n  private lastFetch = new Map<string, number>()\n  private readonly dedupe: boolean\n  private readonly dedupeInterval: number\n  private readonly onError?: (error: unknown, key: string) => void\n  private readonly onSuccess?: (data: unknown, key: string, isRevalidation: boolean) => void\n\n  constructor(cache: CacheInterface<T>, options: SWROptions = {}) {\n    this.cache = cache\n    this.dedupe = options.dedupe ?? true\n    this.dedupeInterval = options.dedupeInterval ?? 2000\n    this.onError = options.onError\n    this.onSuccess = options.onSuccess\n  }\n\n  private shouldDedupe(key: string): boolean {\n    if (!this.dedupe) return false\n    const last = this.lastFetch.get(key)\n    if (!last) return false\n    return Date.now() - last < this.dedupeInterval\n  }\n\n  async get(\n    key: string,\n    fetcher: () => Promise<T>\n  ): Promise<T> {\n    // Check cache first\n    const cached = await this.cache.getWithStatus(key)\n\n    if (cached && !cached.isStale) {\n      // Fresh data - return immediately\n      return cached.data\n    }\n\n    // Check for inflight request\n    const inflight = this.inflight.get(key)\n    if (inflight) {\n      // Return stale data if available, otherwise wait for inflight\n      if (cached) return cached.data\n      return inflight\n    }\n\n    // Check dedupe\n    if (this.shouldDedupe(key)) {\n      const stale = await this.cache.getStale(key)\n      if (stale !== undefined) return stale\n    }\n\n    // Need to fetch\n    const fetchPromise = this.fetch(key, fetcher, !!cached)\n\n    // If we have stale data, return it immediately\n    if (cached) {\n      // Revalidate in background\n      fetchPromise.catch(() => {\n        // Error handled in fetch()\n      })\n      return cached.data\n    }\n\n    // No cached data - must wait for fetch\n    return fetchPromise\n  }\n\n  private async fetch(\n    key: string,\n    fetcher: () => Promise<T>,\n    isRevalidation: boolean\n  ): Promise<T> {\n    this.lastFetch.set(key, Date.now())\n\n    const promise = fetcher()\n    this.inflight.set(key, promise)\n\n    try {\n      const data = await promise\n      await this.cache.set(key, data)\n      this.onSuccess?.(data, key, isRevalidation)\n      return data\n    } catch (error) {\n      this.onError?.(error, key)\n      throw error\n    } finally {\n      this.inflight.delete(key)\n    }\n  }\n\n  async revalidate(key: string, fetcher: () => Promise<T>): Promise<T> {\n    return this.fetch(key, fetcher, true)\n  }\n\n  async mutate(key: string, data: T): Promise<void> {\n    await this.cache.set(key, data)\n  }\n\n  isValidating(key: string): boolean {\n    return this.inflight.has(key)\n  }\n}\n\nexport function createSWR<T>(\n  cache?: CacheInterface<T>,\n  options?: SWROptions\n): SWRCache<T> {\n  const defaultCache = new MemoryCache<T>(CACHE_PRESETS.STATIC)\n  return new SWRCache<T>(cache ?? defaultCache, options)\n}\n\nexport function createPersistentSWR<T>(\n  cache: PersistentCache<T>,\n  options?: SWROptions\n): SWRCache<T> {\n  return new SWRCache<T>(cache, options)\n}\n\n// Convenience function for PokeAPI-style fetching\nexport function createPokeAPIFetcher<T>(\n  baseUrl: string,\n  cache?: CacheInterface<T>,\n  options?: SWROptions\n): (endpoint: string) => Promise<T> {\n  const swr = createSWR<T>(cache, options)\n\n  return async (endpoint: string): Promise<T> => {\n    const url = endpoint.startsWith('http') ? endpoint : `${baseUrl}${endpoint}`\n    const key = url\n\n    return swr.get(key, async () => {\n      const response = await fetch(url)\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n      return response.json() as Promise<T>\n    })\n  }\n}\n"]}